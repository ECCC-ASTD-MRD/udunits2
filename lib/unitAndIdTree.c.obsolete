/*
 * Searchable unit-and-identifier tree.
 *
 * $Id: unitAndIdTree.c.obsolete,v 1.1 2006/11/16 20:21:06 steve Exp $
 */

/*LINTLIBRARY*/

#ifndef	_XOPEN_SOURCE
#   define _XOPEN_SOURCE 500
#endif

#include <stdlib.h>
#include <string.h>
#include <search.h>

#include "unitAndIdTree.h"
#include "units.h"


/*
 * Arguments:
 *	unit	The unit.  May be freed upon return.
 *	id	The identifier (name or symbol).  May be freed upon return.
 * Returns:
 *	NULL	Failure.  "unitStatus" will be
 *		    UT_BADARG	"unit" or "id" is NULL.
 *		    UT_OS	Operating-system failure.  See "errno".
 *	else	Pointer to the new unit-and-identifier.
 */
UnitAndId*
uaiNew(
    utUnit* const	unit,
    const char* const	id)
{
    UnitAndId*	entry = NULL;

    if (id == NULL || unit == NULL) {
	unitStatus = UT_BADARG;
    }
    else {
	entry = malloc(sizeof(UnitAndId));

	if (entry == NULL) {
	    unitStatus = UT_OS;
	}
	else {
	    unitStatus = UT_SUCCESS;

	    entry->id = strdup(id);

	    if (entry->id == NULL) {
		unitStatus = UT_OS;
	    }
	    else {
		entry->unit = utClone(unit);

		if (unitStatus != UT_SUCCESS)
		    free(entry->id);
	    }

	    if (unitStatus != UT_SUCCESS) {
		free(entry);
		entry = NULL;
	    }
	}
    }

    return entry;
}


void
uaiFree(
    UnitAndId* const	entry)
{
    if (entry != NULL) {
	free(entry->id);
	utFree(entry->unit);
	free(entry);
    }
}


/*
 * Returns a new instance of a unit-and-identifier tree.
 *
 * Arguments:
 *	compare		Pointer to the comparison function.
 * Returns
 *	NULL		Failure.  "unitStatus" will be
 *			    UT_BADARG	"compare" is NULL.
 *			    UT_OS	Operating-system failure.  See "errno".
 *	UT_SUCCESS	Success.
 */
UnitAndIdTree*
uaiNewTree(
    int			(*compare)(const void*, const void*))
{
    UnitAndIdTree*	tree = NULL;	/* failure */

    if (tree == NULL || compare == NULL) {
	unitStatus = UT_BADARG;
    }
    else {
	tree = (UnitAndIdTree*)malloc(sizeof(UnitAndIdTree));

	if (tree == NULL) {
	    unitStatus = UT_OS;
	}
	else {
	    tree->root = NULL;
	    tree->compare = compare;
	    unitStatus = UT_SUCCESS;
	}
    }

    return tree;
}


/*
 * Returns the unit-and-identifier entry that matches a target entry.  Inserts a
 * new entry if no matching entry is found.  Note that the returned entry might
 * not be the same as the target entry.
 *
 * Arguments:
 *	tree		Pointer to the unit-and-identifier tree.
 *	targetNode	Pointer to the target entry.
 * Returns:
 *	NULL		Failure.  "unitStatus" will be
 *			    UT_BADARG	"tree" is NULL or "targetNode" is NULL.
 *	NULL		Insufficient storage space is available.
 *	else		Pointer to the unit search-node that matches 
 *			"targetNode" according to the tree's comparison
 *			function.
 */
UnitAndId*
uaiSearch(
    UnitAndIdTree* const	tree,
    const UnitAndId* const	targetEntry)
{
    UnitAndId*	entry = NULL;		/* failure */

    if (tree == NULL || targetEntry == NULL) {
	unitStatus = UT_BADARG;
    }
    else {
	UnitAndId**	treeEntry =
	    tsearch(targetEntry, &tree->root, tree->compare);

	if (treeEntry == NULL) {
	    unitStatus = UT_OS;
	}
	else {
	    entry = *treeEntry;
	    unitStatus = UT_SUCCESS;
	}
    }

    return entry;
}


/*
 * Returns the unit-and-identifier entry that matches a target entry.  Unlike
 * uaiSearch(), this function does not insert a new entry if no matching entry
 * is found.
 *
 * Arguments:
 *	tree		Pointer to the unit-and-identifier tree.
 *	targetEntry	Pointer to the target entry.
 * Returns:
 *	NULL		Failure.  "unitStatus" will be
 *			    UT_BADARG	"tree" is NULL or "targetEntry" is NULL.
 *			    UT_SUCCESS	The tree doesn't have a matching entry.
 *	else		Pointer to the entry that matches "targetEntry"
 *			according to the tree's comparison function.
 */
UnitAndId*
uaiFind(
    UnitAndIdTree* const	tree,
    const UnitAndId* const	targetEntry)
{
    UnitAndId*	entry = NULL;	/* failure */

    if (tree == NULL || targetEntry == NULL) {
	unitStatus = UT_BADARG;
    }
    else {
	UnitAndId**	treeEntry =
	    tfind(targetEntry, &tree->root, tree->compare);

	if (treeEntry != NULL)
	    entry = *treeEntry;

	unitStatus = UT_SUCCESS;
    }

    return entry;
}


/*
 * Returns the unit-and-identifier entry that matches a target entry.  Unlike
 * uaiSearch(), this function does not insert a new entry if no matching entry
 * is found.
 *
 * Arguments:
 *	tree		Pointer to the unit-and-identifier tree.
 *	targetEntry	Pointer to the target entry.
 * Returns:
 *	NULL		Failure.  "unitStatus" will be
 *			    UT_BADARG	"tree" is NULL or "targetEntry" is NULL.
 *			    UT_SUCCESS	The tree doesn't have a matching entry.
 *	else		Pointer to the entry that matches "targetEntry"
 *			according to the tree's comparison function.
 */
const UnitAndId*
uaiFindByUnit(
    const UnitAndIdTree* const	tree,
    const utUnit* const		unit)
{
    const UnitAndId*	entry = NULL;	/* failure */

    if (tree == NULL || unit == NULL) {
	unitStatus = UT_BADARG;
    }
    else {
	UnitAndId		targetEntry;
	const UnitAndId* const*	treeEntry;

	targetEntry.unit = unit;
	treeEntry = tfind(&targetEntry, &tree->root, tree->compare);

	if (treeEntry != NULL)
	    entry = *treeEntry;

	unitStatus = UT_SUCCESS;
    }

    return entry;
}


utStatus
uaiRemove(
    UnitAndIdTree*		tree,
    const UnitAndId* const	targetEntry)
{
    if (tree == NULL || targetEntry == NULL) {
	unitStatus = UT_BADARG;
    }
    else {
	UnitAndId**	treeEntry =
	    tfind(targetEntry, tree->root, tree->compare);

	if (treeEntry != NULL) {
	    (void)tdelete(*treeEntry, tree, compare);
	    uaiFree(*treeEntry);
	}
    }
}
