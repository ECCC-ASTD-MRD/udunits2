/*
 * Module for key-to-pointer maps.
 *
 * This module is thread-compatible but not thread-safe.
 *
 * $Id: map.c.obsolete,v 1.1 2006/11/16 20:21:06 steve Exp $
 */

/*LINTLIBRARY*/

#ifndef	_XOPEN_SOURCE
#   define _XOPEN_SOURCE 500
#endif

#include <search.h>
#include <stdlib.h>

#include "map.h"

struct Map {
    void*	tree;
    int		(*compare)(const void*, const void*);
};

typedef struct {
    const void*	key;
    void*	ptr;
} Entry;

static int	(*compareKeys)(const void*, const void*);


/*
 * Compares two map entries according to their keys.
 *
 * Arguments:
 *	entry1	Pointer to the first entry.
 *	entry2	Pointer to the second entry.
 * Returns:
 *	-1	The first entry's key is less than the second's.
 *	 0	The first entry's key is equal to the second's.
 *	 1	The first entry's key is greater than the second's.
 */
static int
compareEntries(
    const void*	entry1,
    const void*	entry2)
{
    return compareKeys(((Entry*)entry1)->key, ((Entry*)entry2)->key);
}


/*
 * Returns a new instance of a map.
 *
 * Arguments:
 *	compare	Function for comparing keys.
 * Returns:
 *	NULL	Operating-system failure.  See "errno".
 *	else	Pointer to the new map.
 */
Map*
mapNew(
    int	(*compare)(const void*, const void*))
{
    Map*	map = (Map*)malloc(sizeof(Map));

    if (map != NULL) {
	map->tree = NULL;
	map->compare = compare;
    }

    return map;
}


/*
 * Returns the address of the pointer to which a key maps.
 *
 * Arguments:
 *	map	Pointer to the map.
 *	key	Pointer to the key.
 * Returns:
 *	NULL	There is no pointer associated with "key".
 *	else	Address of the pointer to which "key" maps.
 */
void**
mapFind(
    const Map* const	map,
    const void* const	key)
{
    Entry	targetEntry;
    Entry**	treeEntry;

    targetEntry.key = key;
    compareKeys = map->compare;
    treeEntry = tfind(&targetEntry, &map->tree, compareEntries);

    return
	treeEntry == NULL
	    ? NULL
	    : &(*treeEntry)->ptr;
}


/*
 * Returns the address of the pointer to which a key maps -- creating a new
 * entry if necessary.  If a new entry is created, then the pointer whose
 * address is returned will be NULL.
 *
 * Arguments:
 *	map	Pointer to the map.
 *	key	Pointer to the key.
 * Returns:
 *	NULL	Operating system failure.  See "errno".
 *	else	Address of the pointer to which "key" maps.
 */
void**
mapSearch(
    Map* const	map,
    const void*	key)
{
    void**	addr = NULL;		/* failure */
    Entry*	targetEntry = (Entry*)malloc(sizeof(Entry));

    if (targetEntry != NULL) {
	Entry**	treeEntry;

	targetEntry->key = key;
	compareKeys = map->compare;
	treeEntry = tsearch(targetEntry, &map->tree, compareEntries);

	if (treeEntry == NULL) {
	    free(targetEntry);
	}
	else {
	    addr = &(*treeEntry)->ptr;

	    if (targetEntry != *treeEntry)
		free(targetEntry);
	}
    }

    return addr;
}


/*
 * Removes the map entry that corresponds to a key.
 *
 * Arguments:
 *	map	Pointer to the map.
 *	key	Pointer to the key.
 */
void
mapRemove(
    Map* const		map,
    const void* const	key)
{
    Entry	targetEntry;
    Entry**	treeEntry;

    targetEntry.key = key;
    compareKeys = map->compare;
    treeEntry = tfind(&targetEntry, &map->tree, compareEntries);

    if (treeEntry != NULL) {
	(void)tdelete(&targetEntry, &map->tree, compareEntries);
	free(*treeEntry);
    }
}


/*
 * Frees a map.  This function should be called when a map is no longer needed.
 *
 * Arguments:
 *	map	Pointer to the map to be freed or NULL.  Use of "map" upon
 *		return results in undefined behavior.
 */
void
mapFree(
    Map* const	map)
{
    if (map != NULL) {
	compareKeys = map->compare;

	while (map->tree != NULL) {
	    Entry*	entry = *(Entry**)map->tree;

	    tdelete(entry->key, &map->tree, compareEntries);
	    free(entry);
	}

	free(map);
    }
}
